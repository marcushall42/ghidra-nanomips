define endian=$(ENDIAN);

define alignment=2;

define space ram        type=ram_space size=4 default;
define space register   type=register_space size=4;

define register offset=0 size=4 [
  zero at v0 v1 a0 a1 a2 a3
    t0 t1 t2 t3 t4 t5 t6 t7
    s0 s1 s2 s3 s4 s5 s6 s7
    t8 t9 k0 k1 gp sp s8 ra
    pc
# Exception and Debug pcs, Status
       epc depc Status
];

# Instructions are 2, 4, or 6 bytes long.  We consider 2-byte "narrow"
# instructions and 4-byte "instructions" that may have an additional 2-byte
# upper address portion appended.
#
# The manual numbers the bits as a 16, 32, or 48 bit long instruction.
# 16-bit instructions are stored:
#  byte    little  big
#  0:      0-7     8-15
#  1:      8-15    0-7
#
# 32-bit instructions are stored:
#  byte    little  big      ghidra-little
#  0:      16-23   24-31    0-7
#  1:      24-31   16-23    8-15
#  2:      0-7     8-15     16-23
#  3:      8-15    0-7      24-31
#
# So, the first word is the high word, regardless of the byte order.
# This is also the word that contains the opcode, which decodes the
# instruction length.  So, in the manual the opcode is in bits 10-15
# of a 2-byte instruction or 26-31 of a 4-byte instruction, they occur
# in the high byte of the first 2 bytes..
#
# Because ghidra considers a 4-byte little endian instruction to be
# ordered with bits strictly little-endian, we map the token bits
# for little-endian between the two half-words.

# narrow instruction
define token ins16(16)
    n_op    = (10,15)
    rtz3    = (7,9)
    rt3     = (7,9)
    rs3     = (4,6)
    rd3     = (1,3)
    rtz4x   = (5,9)
    rt4x    = (5,9)
    rsz4x   = (0,4)
    rs4x    = (0,4)
    rd2x2   = (3,8)
    rd2x1   = (3,8)
    n_rt    = (5,9)
    n_rs    = (0,4)
    rt1     = (9,9)
    rt1_1   = (9,9)
    rt1_2   = (9,9)
    rt1_3   = (9,9)
    rt1_4   = (9,9)
    rt1_5   = (9,9)
    rt1_6   = (9,9)
    rt1_7   = (9,9)
    rt1_8   = (9,9)
    rt1_9   = (9,9)
    rt1_10  = (9,9)
    rt1_11  = (9,9)
    rt1_12  = (9,9)
    rt1_13  = (9,9)
    rt1_14  = (9,9)
    n8      = (8,8)
    n7_9    = (7,9)
    n6      = (6,6)
    n5_9    = (5,9)
    n4_7    = (4,7)
    n4_6    = (4,6)
    n4s     = (4,4) signed
    n3_9    = (3,9)
    n3_4    = (3,4)
    n3      = (3,3)
    n2_9    = (2,9)
    n2_3    = (2,3)
    n1_9    = (1,9)
    n1_6    = (1,6)
    n1_2    = (1,2)
    n1      = (1,1)
    n0_6    = (0,6)
    n0_5    = (0,5)
    n0_4    = (0,4)
    n0_3    = (0,3)
    n0_2    = (0,2)
    n0_1    = (0,1)
    n0      = (0,0)
    n0s     = (0,0) signed
;

# Regular 32-bit instruction
define token ins32(32)
@if ENDIAN == "big"
    i_op    = (26,31)
    op1     = (21,25)
    rt      = (21,25)
    rt_1    = (21,25)
    rt_2    = (21,25)
    rt_3    = (21,25)
    rt_4    = (21,25)
    rt_5    = (21,25)
    rt_6    = (21,25)
    rt_7    = (21,25)
    rt_8    = (21,25)
    rt_9    = (21,25)
    rt_10   = (21,25)
    rt_11   = (21,25)
    rt_12   = (21,25)
    rt_13   = (21,25)
    rt_14   = (21,25)
    rs      = (16,20)
    i_rt3   = (23,25)
    i_rs3   = (20,22)
    rd1     = (24,24)
    i_rtz4x = (21,25)
    c0s     = (16,20)
    i26     = (26,26)
    i25     = (25,25)
    i21_25  = (21,25)
    i20     = (20,20)
    i19_25  = (19,25)
    i19     = (19,19)
    i18_25  = (18,25)
    i18_20  = (18,20)
    i17     = (17,17)
    i16_25  = (16,25)
    i16_24  = (16,24)
    i16_20  = (16,20)
    i16_19  = (16,19)
    i16_18  = (16,18)
    i16_17  = (16,17)
    i16     = (16,16)
    rd      = (11,15)
    ru      = (3,7)
    i15s    = (15,15) signed
    i14_15  = (14,15)
    i12_15  = (12,15)
    i12_14  = (12,14)
    i11_15  = (11,15)
    i11     = (11,11)
    i10     = (10,10)
    i9_10   = (9,10)
    i8_14   = (8,14)
    i8_11   = (8,11)
    i7_10   = (7,10)
    i6_10   = (6,10)
    i6      = (6,6)
    i5_8    = (5,8)
    i5      = (5,5)
    i3_11   = (3,11)
    i3_9    = (3,9)
    i2_15   = (2,15)
    i2_11   = (2,11)
    i2_7    = (2,7)
    i1_15   = (1,15)
    i1_13   = (1,13)
    i1_10   = (1,10)
    i1      = (1,1)
    i0_15   = (0,15)
    i0_12   = (0,12)
    i0_11   = (0,11)
    i0_10   = (0,10)
    i0_9    = (0,9)
    i0_8    = (0,8)
    i0_7    = (0,7)
    i0_5    = (0,5)
    i0_4    = (0,4)
    i0_2    = (0,2)
    i0_1    = (0,1)
    i0      = (0,0)
    i0s     = (0,0) signed
@else
    i_op    = (10,15)
    op1     = (5,9)
    rt      = (5,9)
    rt_1    = (5,9)
    rt_2    = (5,9)
    rt_3    = (5,9)
    rt_4    = (5,9)
    rt_5    = (5,9)
    rt_6    = (5,9)
    rt_7    = (5,9)
    rt_8    = (5,9)
    rt_9    = (5,9)
    rt_10   = (5,9)
    rt_11   = (5,9)
    rt_12   = (5,9)
    rt_13   = (5,9)
    rt_14   = (5,9)
    rs      = (0,4)
    i_rt3   = (7,9)
    i_rs3   = (4,6)
    rd1     = (8,8)
    i_rtz4x = (5,9)
    c0s     = (0,4)
    i26     = (10,10)
    i25     = (9,9)
    i21_25  = (5,9)
    i20     = (4,4)
    i19_25  = (3,9)
    i19     = (3,3)
    i18_25  = (2,9)
    i18_20  = (2,4)
    i17     = (1,1)
    i16_25  = (0,9)
    i16_24  = (0,8)
    i16_20  = (0,4)
    i16_19  = (0,3)
    i16_18  = (0,2)
    i16_17  = (0,1)
    i16     = (0,0)
    rd      = (27,31)
    ru      = (19,23)
    i15s    = (31,31) signed
    i14_15  = (30,31)
    i12_15  = (28,31)
    i12_14  = (28,30)
    i11_15  = (27,31)
    i11     = (27,27)
    i10     = (26,26)
    i9_10   = (25,26)
    i8_14   = (24,30)
    i8_11   = (24,27)
    i7_10   = (23,26)
    i6_10   = (22,26)
    i6      = (22,22)
    i5_8    = (21,24)
    i5      = (21,21)
    i3_11   = (19,27)
    i3_9    = (19,25)
    i2_15   = (18,31)
    i2_11   = (18,27)
    i2_7    = (18,23)
    i1_15   = (17,31)
    i1_13   = (17,29)
    i1_10   = (17,26)
    i1      = (17,17)
    i0_15   = (16,31)
    i0_12   = (16,28)
    i0_11   = (16,27)
    i0_10   = (16,26)
    i0_9    = (16,25)
    i0_8    = (16,24)
    i0_7    = (16,23)
    i0_5    = (16,21)
    i0_4    = (16,20)
    i0_2    = (16,18)
    i0_1    = (16,17)
    i0      = (16,16)
    i0s     = (16,16) signed
@endif
;
define token ins48ext(16)
    e0_15s  = (0,15) signed
;

#imm16: u1 is ; u1 { export u1; }

attach variables [ rs n_rs rt n_rt rd ru ] [
  zero at v0 v1 a0 a1 a2 a3
    t0 t1 t2 t3 t4 t5 t6 t7
    s0 s1 s2 s3 s4 s5 s6 s7
    t8 t9 k0 k1 gp sp s8 ra
];
attach variables [ rs3 i_rs3 rt3 i_rt3 rd3 ] [
    s0 s1 s2 s3 a0 a1 a2 a3
];
attach variables [ rtz3 ] [
    zero s1 s2 s3 a0 a1 a2 a3
];
attach variables [ rs4x rt4x ] [ # 4 bits with ignored bit inserted 3.210
    t0 t1 t2 t3 a0 a1 a2 a3 t0 t1 t2 t3 a0 a1 a2 a3
    s0 s1 s2 s3 s4 s5 s6 s7 s0 s1 s2 s3 s4 s5 s6 s7
];
attach variables [ rsz4x rtz4x i_rtz4x ] [ # similar, but $3 == zero
    t0 t1 t2 zero a0 a1 a2 a3 t0 t1 t2 t3 a0 a1 a2 a3
    s0 s1 s2 s3 s4 s5 s6 s7 s0 s1 s2 s3 s4 s5 s6 s7
];
attach variables [ rd2x1 ] [ # a0, a1, a2, a3; but bits are b0 x x x x b1
 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 a0 # b0=0 b1=0
 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 # b0=0 b1=1
 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 # b0=1 b1=0
 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 # b0=1 b1=1
];
attach variables [ rd2x2 ] [ # a1, a2, a3, t0; but bits are b0 x x x x b1
 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 a1 # b0=0 b1=0
 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 a3 # b0=0 b1=1
 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 a2 # b0=1 b1=0
 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 t0 # b0=1 b1=1
];
attach variables [ rd1 ] [ a0 a1 ];
attach variables [ rt1 ] [ s8 ra ];

# Additiona mappings of registers rt and rt1 used for lwm/restore/save/swm.
# rt_X and rt1_X are mappings of rt/rt1 + X, wrapping to s0 after ra.
attach variables [ rt_1 ] [
    at v0 v1 a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0
    s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp s8 ra s0
];
attach variables [ rt_2 ] [
    v0 v1 a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1
    s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp s8 ra s0 s1
];
attach variables [ rt_3 ] [
    v1 a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2
    s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp s8 ra s0 s1 s2
];
attach variables [ rt_4 ] [
    a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3
    s4 s5 s6 s7 t8 t9 k0 k1 gp sp s8 ra s0 s1 s2 s3
];
attach variables [ rt_5 ] [
    a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4
    s5 s6 s7 t8 t9 k0 k1 gp sp s8 ra s0 s1 s2 s3 s4
];
attach variables [ rt_6 ] [
    a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5
    s6 s7 t8 t9 k0 k1 gp sp s8 ra s0 s1 s2 s3 s4 s5
];
attach variables [ rt_7 ] [
    a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6
    s7 t8 t9 k0 k1 gp sp s8 ra s0 s1 s2 s3 s4 s5 s6
];
attach variables [ rt_8 ] [
    t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7
    t8 t9 k0 k1 gp sp s8 ra s0 s1 s2 s3 s4 s5 s6 s7
];
attach variables [ rt_9 ] [
    t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8
    t9 k0 k1 gp sp s8 ra s0 s1 s2 s3 s4 s5 s6 s7 t8
];
attach variables [ rt_10 ] [
    t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9
    k0 k1 gp sp s8 ra s0 s1 s2 s3 s4 s5 s6 s7 t8 t9
];
attach variables [ rt_11 ] [
    t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0
    k1 gp sp s8 ra s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0
];
attach variables [ rt_12 ] [
    t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1
    gp sp s8 ra s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1
];
attach variables [ rt_13 ] [
    t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp
    sp s8 ra s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp
];
attach variables [ rt_14 ] [
    t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp
    s8 ra s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp
];
attach variables [ rt1_1 ] [ ra s0 ];  # rt1 + 1
attach variables [ rt1_2 ] [ s0 s1];  # rt1 + 2
attach variables [ rt1_3 ] [ s1 s2 ];  # rt1 + 3
attach variables [ rt1_4 ] [ s2 s3 ];  # rt1 + 4
attach variables [ rt1_5 ] [ s3 s4 ];  # rt1 + 5
attach variables [ rt1_6 ] [ s4 s5 ];  # rt1 + 6
attach variables [ rt1_7 ] [ s5 s6 ];  # rt1 + 7
attach variables [ rt1_8 ] [ s6 s7 ];  # rt1 + 8
attach variables [ rt1_9 ] [ s7 t8 ];  # rt1 + 9
attach variables [ rt1_10 ] [ t8 t9 ];  # rt1 + 10
attach variables [ rt1_11 ] [ t9 k0 ];  # rt1 + 11
attach variables [ rt1_12 ] [ k0 k1 ];  # rt1 + 12
attach variables [ rt1_13 ] [ k1 gp ];  # rt1 + 13
attach variables [ rt1_14 ] [ gp sp ];  # rt1 + 14

define pcodeop trap;
define pcodeop cacheOp;
#define pcodeop disableInterrupts;
#define pcodeop enableInterrupts;
define pcodeop disableProcessor;
define pcodeop enableProcessor;
define pcodeop crc32;
define pcodeop countLeadingOnes;
define pcodeop countLeadingZeros;
define pcodeop read_cp0_register;
define pcodeop write_cp0_register;
define pcodeop pause;
define pcodeop read_hw;
define pcodeop rotx;
